h1. *wsl-components*

h2. *Introduction*

*WSL Components* is general purpose PHP components library with the goal of aiding in the development of PHP applications. By using *WSL Components* you will not have to reinvent the wheel again. Each package is focused on a specific purpose, for example WSL_Config handles configuration INI files or WSL_FormValidator validates the data received by a form.

h3. *Installation Guide*

The easiest way to install our packages on your local system is by using the PEAR installer. You can also checkout a copy of the code from our SVN repository. Despite each package works independently, it may have dependencies on other packages. This is one reason why we encourage you to use PEAR.

h4. *PEAR Installer*

Once you have installed the PEAR Installer you can proceed to installing the package that you need. For example, if you are interested on installing WSL_Config, you can do it just by executing the following commands in your shell prompt: 

<pre><code>
pear channel-discover pear.weblogssl.com
pear install -a WSL/WSL_Config
</code></pre>

You will be able to upgrade to future versions of WSL_Config by executing: 

<pre><code>
pear upgrade WSL/WSL_Config
</code></pre> 

h5. SVN

The procedure for checking out the SVN repository is quite simple aswell. You can get the whole set of packages (or any module therein) by executing the following command: 

<pre><code>
svn checkout http://wsl-components.googlecode.com/svn/trunk/ wsl-components-read-only
</code></pre>

h4. Available Packages

Currently we have these packages ready to use: 

h1.  *WSL_Config*

h4.  Introduction

*WSL_Config* is a component that allows you to handle configuration INI files. It also lets you to merge different configuration files.

An example of a INI file structure could be:

<pre><code>
section]
key1="hello"
key2="world"

[section2]
key1="foo"
</code></pre>

h4.  *Installation*

h4.  *PEAR*

<pre><code>
pear channel-discover pear.weblogssl.com
pear install -a WSL/WSL_Config
</code></pre>

h4.  *SVN*

<pre><code>
svn co http://wsl-components.googlecode.com/svn/trunk/Config wsl-components-read-only
</code></pre>

h2.  **Methods**

h4. *Config.php*

* public WSL_Config *__construct*(string $file)


This is the WSL_Config constructor, it creates a WSL_Config object. You need to provide the file path that you want to read. If the file does not exist or cannot be opened, it will throw an exception.


* public array *getSection*(string $section)

This method returns an array containing the data of the section provided through the input parameter.

* public mixed *getValue*(string $section, string $key)

This method returns a specific key value from a section. If the section or the key does not exist in the object, it will return null.

* public boolean *setValue*(string $section, string $key, mixed $value)

This method sets a key-value pair into a section. If the section does not exist, it will be created automatically. The key cannot be null, otherwise the method will raise an exception. The method will return true unless the key is empty.

* public string *getFileName*()

This method returns the file which is being read by the object.

* public array *toArray*()

This method returns an array containing a representing tree of the whole configuration file.

* public void *merge*(WSL_Config $config, boolean $override=true)

This method merges two WSL_Config objects. If $override is true, the original section values will be overridden by the new ones. Otherwise the shared section values will be ignored.

h2. *Examples*

h3. *Example1.Reading configuration from a INI file*

<pre><code>
<?php
    require 'WSL/Config/Config.php';

    try {
        $config = new WSL_Config('file.ini');
    } catch (Exception $e) {
        echo '[ERROR]: '. $e->getMessage();
    }

    // this prints all the information stored
    echo var_dump($config->toArray());
?>


</code></pre> 

h3. *Example 2. Getting a certain value from a INI file*

<pre><code>
<?php
    require 'WSL/Config/Config.php';

    try {
        $config = new WSL_Config('file.ini');
    } catch (Exception $e) {
        echo '[ERROR]: '. $e->getMessage();
    }

    $value = $config->getValue('section', 'key');
?>
</code></pre>

h3. *Example 3. Merging two WSL_Config objects*

Note: This is pretty useful when you try to build a system which can handle several kinds/levels of configuration. At Weblogs SL, we use this in order to have two levels of configuration: general and specific (for each blog): 

<pre><code>
<?php
    require 'WSL/Config/Config.php';

    try {
        $config1 = new WSL_Config('file.ini');
        $config2 = new WSL_Config('file2.ini');
    } catch (Exception $e) {
        echo '[ERROR]: '. $e->getMessage();
    }

    // Now $config1 contains $config2 as well
    $config1->merge($config2);
?>
</code></pre>


h1. *WSL_Dispatcher*

h2. *Introduction*

*WSL_Dispatcher* is a component that provides functionality for HTTP request parsing, routing and dispatching. You only need to define all the routes of your web application and *WSL_Dispatcher* will do everything for you. 

A dispatcher is an essential component of a MVC pattern, since it forwards the frontend requests to the specified application controller. 

h4. *Installation*

h4. *PEAR*

<pre><code>
pear channel-discover pear.weblogssl.com
pear install -a WSL/WSL_Dispatcher
</code></pre>

h4. *SVN*

<pre><code>
svn co http://wsl-components.googlecode.com/svn/trunk/Dispatcher wsl-components-read-only
</code></pre>

h4. *Package Dependencies*

h2. *Methods*

h3. *Dispatcher.php*

* public WSL_Dispatcher *__construct*(WSL_Config $routes, boolean $cache = false)



This is the WSL_Dispatcher constructor, it creates a WSL_Dispatcher object. You need to pass a WSL_Config object as parameter. This object should contain the available routes (if you want to know how to define routes, please have a look at the Defining routes section). It also has a second parameter which turns on the routes cache. We rather recommend the use of the cache, since it speeds up the route search process.

* public array *toParams*(string $url)



This method translates a URL into an array containing a set of parameters which tells us what controller and action need to be executed by the application. This array could contain information passed through the URL (dynamic URLs).

* public string *toURL*(array $params)



This method does exactly the opposite of toParams. It translates from a set of parameters to a URL string. The input array needs to contain at least the controller and the action. In case it's a dynamic URL, you need to specify the variable values into the parameters array. For example (URL: /person/:name)

<pre><code>
<?php
    $params = array('controller' => 'Controller.Example',
                    'action'     => 'exampleAction',
                    'name'       => 'alexandra');

    // $url contains /person/alexandra
    $url = $dispatcher->toURL($params);
?>
</code></pre>

*WSL_Dispatcher* has other two files: Router.php and Node.php. These two files contains classes which are used by Dispatcher.php. If you want to know more about them, please have a look at the source.

h3. *Defining routes*

Before using *WSL_Dispatcher*, we need to define our application routes in a file and afterwards load that file into a WSL_Dispatcher object. The format which we will use in order to define the routes is INI. Let's define some sample routes:

<pre><code>
;Simple Route

[simpleroute]
route = "/example"
controller = "Controller.Example"
action = "exampleAction"


;Dynamic Route

[dynamicroute]
route = "/book/:title"
controller = "Controller.Books"
action = "getBookByTitle"


;Complex Dynamic Route

[complexdynamicroute]
route = "/book/:year/:title/"
controller = "Controller.Books"
action = "getBookByYearAndTitle"
requirement.year = "\d{4}"
requirement.title = "[a-z]+"
</code></pre>
 
As you can see in the last example, it's possible to use *regular expressions* in your routes definition. You can also define static values by using meta.value, for example: 

<pre><code>
;Simple Route

[simpleroute]
route = "/example"
controller = "Controller.Example"
action = "exampleAction"
meta.cache_lifetime = 3600
</code></pre>

h2. *Examples*

h3. *Example 1. Creating a WSL_Dispatcher Object*

<pre><code>
<?php
    require_once 'WSL/Dispatcher/Dispatcher.php';

    $routes = new WSL_Config('routes.ini');

    $dispatcher = new WSL_Dispatcher($routes);
?>
</code></pre>

h3. *Example 2. Getting the Parameters*

<pre><code>
<?php
    require_once 'WSL/Dispatcher/Dispatcher.php';

    $routes     = new WSL_Config('routes.ini');
    $dispatcher = new WSL_Dispatcher($routes);

    // Note: We recommend you to use WSL_Request::getPath()
    $url = $_SERVER['REQUEST_URI'];

    $params = $dispatcher->toParams($url);
?>
</code></pre>

h3. *Example 3. Getting the URL*
<pre><code>
<?php
    require_once 'WSL/Dispatcher/Dispatcher.php';

    $routes     = new WSL_Config('routes.ini');
    $dispatcher = new WSL_Dispatcher($routes);

    $params = array('controller' => 'Controller.Posts',
                    'action'     => 'post',
                    'title'      => 'post-title',
                    'year'       => '1986',
                    'month'      => '10',
                    'day'        => '04');

    $url = $dispatcher->toURL($params);
?>
</code></pre>  
